装饰者模式（Decorator Pattern）,别名包装器（Wrapper）这个和适配器别名一样了。

1、定义：
动态的给一个对象增加一些额外的职责；

定义也就是说，给一个对象或者类增加一些行为；

增加行为，继承也可以做到，关联机制也可以做到；
关联机制就是我们要讲的装饰着模式，将A嵌入到B中，由B来决定是否调用A来扩展自己的行为。这个就是装饰器；

这个和继承有啥区别呢？

继承可以在拥有本身的一些方法上，还拥有来父类的方法；特点是静态的，自己不能控制增加行为的方式及时机；

继承：耦合度高，静态的，无法在程序运行时扩展；
关联关系：松耦合，动态的，缺点，有可能会创建更多对象；装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。

装饰者模式，是透明的方式给一个对象附加一些职责，客户端并不会感到装饰前后有什么区别；
不会像继承那样，创建一些子类；

变形金刚电影都看过，举个变形金刚的例子；

变形前：汽车；
变形后：变成机器人，能在陆地移动，可以说话，还可以变成飞机；



装饰模式可分为1）透明装饰模式和2）半透明装饰模式：
1）在透明装饰模式中，
要求客户端完全针对抽象编程，装饰模式的透明性要求客户端程序不应该声明具体构件类型和具体装饰类型，
而应该全部声明为抽象构件类型；
2）半透明装饰模式允许用户在客户端声明具体装饰者类型的对象，调用在具体装饰者中新增的方法。


缺点：
1、进行系统设计时将产生很多小对象
2、装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。





